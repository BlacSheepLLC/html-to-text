{"version":3,"sources":["../node_modules/striptags/src/striptags.js","utils.js","index.js"],"names":["compose","fns","reduce","f","g","htmlToText","blocks","unparsable","preprocess","html","removeTextStyling","replace","removeUnparsableElements","element","RegExp","removeSilentElements","parseLinks","parseImages","breakOnBlocks","block","removeExtraBreakLines","removeBlocks","parseListItems","replaceSpaces","removeLeadingNewLines","removeTrailingNewLines","removeAllNonTagsToBreakOn","convertTagsToBreak","removeIndentation"],"mappings":"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","file":"html-to-text.min.js","sourceRoot":"../src","sourcesContent":["'use strict';\n\n(function (global) {\n\n    // minimal symbol polyfill for IE11 and others\n    if (typeof Symbol !== 'function') {\n        var Symbol = function(name) {\n            return name;\n        }\n\n        Symbol.nonNative = true;\n    }\n\n    const STATE_PLAINTEXT = Symbol('plaintext');\n    const STATE_HTML      = Symbol('html');\n    const STATE_COMMENT   = Symbol('comment');\n\n    const ALLOWED_TAGS_REGEX  = /<(\\w*)>/g;\n    const NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n\n    function striptags(html, allowable_tags, tag_replacement) {\n        html            = html || '';\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return striptags_internal(html, context);\n    }\n\n    function init_striptags_stream(allowable_tags, tag_replacement) {\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return function striptags_stream(html) {\n            return striptags_internal(html || '', context);\n        };\n    }\n\n    striptags.init_streaming_mode = init_striptags_stream;\n\n    function init_context(allowable_tags, tag_replacement) {\n        allowable_tags = parse_allowable_tags(allowable_tags);\n\n        return {\n            allowable_tags : allowable_tags,\n            tag_replacement: tag_replacement,\n\n            state         : STATE_PLAINTEXT,\n            tag_buffer    : '',\n            depth         : 0,\n            in_quote_char : ''\n        };\n    }\n\n    function striptags_internal(html, context) {\n        let allowable_tags  = context.allowable_tags;\n        let tag_replacement = context.tag_replacement;\n\n        let state         = context.state;\n        let tag_buffer    = context.tag_buffer;\n        let depth         = context.depth;\n        let in_quote_char = context.in_quote_char;\n        let output        = '';\n\n        for (let idx = 0, length = html.length; idx < length; idx++) {\n            let char = html[idx];\n\n            if (state === STATE_PLAINTEXT) {\n                switch (char) {\n                    case '<':\n                        state       = STATE_HTML;\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        output += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_HTML) {\n                switch (char) {\n                    case '<':\n                        // ignore '<' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // we're seeing a nested '<'\n                        depth++;\n                        break;\n\n                    case '>':\n                        // ignore '>' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // something like this is happening: '<<>>'\n                        if (depth) {\n                            depth--;\n\n                            break;\n                        }\n\n                        // this is closing the tag in tag_buffer\n                        in_quote_char = '';\n                        state         = STATE_PLAINTEXT;\n                        tag_buffer   += '>';\n\n                        if (allowable_tags.has(normalize_tag(tag_buffer))) {\n                            output += tag_buffer;\n                        } else {\n                            output += tag_replacement;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    case '\"':\n                    case '\\'':\n                        // catch both single and double quotes\n\n                        if (char === in_quote_char) {\n                            in_quote_char = '';\n                        } else {\n                            in_quote_char = in_quote_char || char;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case '-':\n                        if (tag_buffer === '<!-') {\n                            state = STATE_COMMENT;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case ' ':\n                    case '\\n':\n                        if (tag_buffer === '<') {\n                            state      = STATE_PLAINTEXT;\n                            output    += '< ';\n                            tag_buffer = '';\n\n                            break;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_COMMENT) {\n                switch (char) {\n                    case '>':\n                        if (tag_buffer.slice(-2) == '--') {\n                            // close the comment\n                            state = STATE_PLAINTEXT;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n        }\n\n        // save the context for future iterations\n        context.state         = state;\n        context.tag_buffer    = tag_buffer;\n        context.depth         = depth;\n        context.in_quote_char = in_quote_char;\n\n        return output;\n    }\n\n    function parse_allowable_tags(allowable_tags) {\n        let tag_set = new Set();\n\n        if (typeof allowable_tags === 'string') {\n            let match;\n\n            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {\n                tag_set.add(match[1]);\n            }\n        }\n\n        else if (!Symbol.nonNative &&\n                 typeof allowable_tags[Symbol.iterator] === 'function') {\n\n            tag_set = new Set(allowable_tags);\n        }\n\n        else if (typeof allowable_tags.forEach === 'function') {\n            // IE11 compatible\n            allowable_tags.forEach(tag_set.add, tag_set);\n        }\n\n        return tag_set;\n    }\n\n    function normalize_tag(tag_buffer) {\n        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n\n        return match ? match[1].toLowerCase() : null;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(function module_factory() { return striptags; });\n    }\n\n    else if (typeof module === 'object' && module.exports) {\n        // Node\n        module.exports = striptags;\n    }\n\n    else {\n        // Browser\n        global.striptags = striptags;\n    }\n}(this));\n","const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\n\nexport { compose };\n","import striptags from 'striptags';\nimport { compose } from './utils';\n\nconst blocks = [\n  'p',\n  'div',\n  'br',\n  'hr',\n  'title',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'ol',\n  'ul',\n  'li',\n  'pre',\n  'table',\n  'th',\n  'td',\n  'blockquote',\n  'header',\n  'footer',\n  'nav',\n  'section',\n  'summary',\n  'aside',\n  'article',\n  'address',\n  'code',\n  'img',\n];\n\nconst unparsable = [\n  'audio',\n  'iframe',\n  'map',\n  'progress',\n  'track',\n  'meter',\n  'object',\n  'svg',\n  'wbr',\n  'video',\n  'webview',\n  'dialog',\n  'canvas',\n];\n\nconst preprocess = html => {\n  return html;\n};\n\nconst removeTextStyling = html => html.replace(/<(\\/)?(b|i|strong|em|font|sup|sub|small|del)>/g, '');\n\nconst removeUnparsableElements = html => {\n  for (const element of unparsable) {\n    html = html.replace(new RegExp(`<${element}(.+?)?>(.+?)?<\\/${element}>`, 'g'), '');\n    html = html.replace(new RegExp(`<${element}(.+?)?\\/>`, 'g'), '');\n    html = html.replace(new RegExp(`<${element}(.+?)>`, 'g'), '');\n  }\n  return html;\n};\n\n// Remove all the elements that don't really matter\nconst removeSilentElements = html => html.replace(/<(\\/)?(ul|ol|span)+(.*?)>/g, '');\n\nconst parseLinks = html => {\n  // First parse all links that have some text\n  html = html.replace(/<a(.+?)href=\"(.+?)\"(.+?)?>(.+?)<\\/a>/g, '$4 ($2)');\n\n  // Remove all those that doesn't\n  return html.replace(/<a(.+?)href=\"(.+?)\"(.+?)?>(.*?)<\\/a>/g, '');\n};\n\nconst parseImages = html => {\n  // Parse images where the alt property is before the src one\n  html = html.replace(/<img(.+?)alt=\"(.+?)\"(.+?)src=\"(.+?)\"(.*?)>/g, 'Image: $2 ($4)');\n\n  // Parse images where the alt property is after the src one\n  html = html.replace(/<img(.+?)src=\"(.+?)\"(.+?)alt=\"(.+?)\"(.*?)>/g, 'Image: $4 ($2)');\n\n  // Parse images where no alt property was provided\n  html = html.replace(/<img(.+?)src=\"(.+?)\"(.*?)>/g, 'Image: $2');\n\n  return html;\n};\n\nconst breakOnBlocks = html => {\n  for (const block of blocks) {\n    html = html.replace(new RegExp(`<\\/${block}>`, 'g'), `</${block}>\\n`);\n    // html = html.replace(new RegExp(`<${block}(.*?)>`, 'g'), `<${block}>`);\n  }\n  return html;\n};\n\nconst removeExtraBreakLines = html => html.replace(/(\\n\\n)+/g, '\\n');\n\nconst removeBlocks = html => {\n  for (const block of blocks) {\n    html = html.replace(new RegExp(`<${block}(.*?)>`, 'g'), '');\n    html = html.replace(new RegExp(`<\\/${block}(.*?)>`, 'g'), '');\n  }\n  return html;\n};\n\nconst parseListItems = html => {\n  // Parse list items that are not empty first\n  html = html.replace(/<li(.*?)>(.+?)<\\/li>/g, '* $2');\n\n  // Remove the empty ones\n  return html.replace(/<li(.*?)>(.*?)<\\/li>/g, '');\n};\n\nconst replaceSpaces = html => html.replace(/&nbsp;/g, ' ');\n\nconst removeLeadingNewLines = html => html.replace(/\\n+$/, '');\n\nconst removeTrailingNewLines = html => html.replace(/^\\n+/, '');\n\nconst removeAllNonTagsToBreakOn = html => striptags(html, blocks);\nconst convertTagsToBreak = html => striptags(html, [], '\\n');\n\nconst removeIndentation = html => {\n  return html.replace(/(^\\t+)/gm, '');\n};\n\nconst htmlToText = compose(\n  removeIndentation,\n\n  convertTagsToBreak,\n  removeAllNonTagsToBreakOn,\n\n  //removeExtraBreakLines,\n  removeLeadingNewLines,\n  removeTrailingNewLines,\n\n  removeBlocks,\n  breakOnBlocks,\n\n  parseImages,\n  parseListItems,\n  parseLinks,\n\n  replaceSpaces,\n  removeTextStyling,\n  removeSilentElements,\n  removeUnparsableElements,\n\n  preprocess,\n);\n\nexport default htmlToText;\n"]}